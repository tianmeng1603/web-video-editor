{"version":3,"file":"static/js/419.631b23c4.chunk.js","mappings":"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","sources":["components/VideoEditor/utils/audioExporter.ts"],"sourcesContent":["/**\r\n * 音频导出模块\r\n * \r\n * 使用FFmpeg.wasm在浏览器中导出音频，支持：\r\n * - 合成视频中的音频轨道\r\n * - 合成所有音频片段\r\n * - 多种音频格式（MP3, WAV, AAC, FLAC, AIFF, OGG）\r\n * - 自定义比特率和采样率\r\n * - 实时进度反馈\r\n */\r\n\r\nimport { FFmpeg } from '@ffmpeg/ffmpeg';\r\nimport { fetchFile } from '@ffmpeg/util';\r\nimport { MediaItem, TimelineClip } from \"../types\";\r\n\r\n/** FFmpeg单例实例 */\r\nlet ffmpegInstance: FFmpeg | null = null;\r\n\r\n/**\r\n * 获取FFmpeg实例（单例模式）\r\n */\r\nconst getFFmpeg = async (): Promise<FFmpeg> => {\r\n  if (ffmpegInstance) return ffmpegInstance;\r\n\r\n  ffmpegInstance = new FFmpeg();\r\n  ffmpegInstance.on('log', ({ message }) => console.log('[FFmpeg Audio]:', message));\r\n  \r\n  const baseURL = 'https://unpkg.com/@ffmpeg/core@0.12.6/dist/umd';\r\n  await ffmpegInstance.load({\r\n    coreURL: `${baseURL}/ffmpeg-core.js`,\r\n    wasmURL: `${baseURL}/ffmpeg-core.wasm`,\r\n  });\r\n\r\n  console.log('✅ FFmpeg (Audio) 加载完成');\r\n  return ffmpegInstance;\r\n};\r\n\r\n/**\r\n * 音频导出配置\r\n */\r\nexport interface AudioExportOptions {\r\n  /** 音频格式 */\r\n  format: string;\r\n  /** 比特率 (kbps) */\r\n  bitrate: string;\r\n  /** 采样率 (Hz) */\r\n  sampleRate: number;\r\n}\r\n\r\n/**\r\n * 导出音频\r\n * \r\n * @param clips - 时间轴片段列表\r\n * @param mediaItems - 媒体素材列表\r\n * @param onProgress - 进度回调函数\r\n * @param options - 导出配置选项\r\n * @returns 导出的音频Blob\r\n */\r\nexport const exportAudio = async (\r\n  clips: TimelineClip[],\r\n  mediaItems: MediaItem[],\r\n  onProgress: (progress: number) => void,\r\n  options: AudioExportOptions\r\n): Promise<Blob> => {\r\n  console.log('🎵 开始导出音频...');\r\n  console.log('导出配置:', options);\r\n  \r\n  const ffmpeg = await getFFmpeg();\r\n  onProgress(10);\r\n\r\n  // 计算总时长\r\n  const maxClipEnd = clips.length > 0 ? Math.max(...clips.map(c => c.end)) : 0;\r\n  const duration = maxClipEnd;\r\n  \r\n  if (duration === 0) {\r\n    throw new Error('没有可导出的音频内容');\r\n  }\r\n\r\n  console.log(`📊 项目总时长: ${duration.toFixed(2)}秒`);\r\n\r\n  // 收集所有音频源（视频音频 + 纯音频）\r\n  const audioSources: Array<{\r\n    clip: TimelineClip;\r\n    media: MediaItem;\r\n    url: string;\r\n  }> = [];\r\n\r\n  for (const clip of clips) {\r\n    const media = mediaItems.find(m => m.id === clip.mediaId);\r\n    if (!media || !media.url) continue;\r\n\r\n    // 视频和音频类型都可能包含音频轨道\r\n    if (media.type === 'video' || media.type === 'audio') {\r\n      audioSources.push({\r\n        clip,\r\n        media,\r\n        url: media.url,\r\n      });\r\n    }\r\n  }\r\n\r\n  console.log(`🎼 找到 ${audioSources.length} 个音频源`);\r\n\r\n  if (audioSources.length === 0) {\r\n    throw new Error('没有找到任何音频轨道');\r\n  }\r\n\r\n  onProgress(20);\r\n\r\n  try {\r\n    // 第一步：加载所有音频文件到FFmpeg\r\n    for (let i = 0; i < audioSources.length; i++) {\r\n      const source = audioSources[i];\r\n      const inputFileName = `input_${i}.mp4`;\r\n      \r\n      console.log(`📥 加载音频文件 ${i + 1}/${audioSources.length}: ${source.media.name}`);\r\n      const audioData = await fetchFile(source.url);\r\n      await ffmpeg.writeFile(inputFileName, audioData);\r\n    }\r\n\r\n    onProgress(40);\r\n\r\n    // 第二步：创建静音基底（项目总时长的静音音频）\r\n    console.log('🔇 创建静音基底...');\r\n    await ffmpeg.exec([\r\n      '-f', 'lavfi',\r\n      '-i', `anullsrc=r=${options.sampleRate}:cl=stereo`,\r\n      '-t', duration.toString(),\r\n      '-ar', options.sampleRate.toString(),\r\n      'silence.wav'\r\n    ]);\r\n\r\n    onProgress(50);\r\n\r\n    // 第三步：创建 FFmpeg 滤镜复杂链\r\n    let filterComplex = '';\r\n    const mixInputs: string[] = ['[0:a]']; // 静音基底（注意要加方括号）\r\n\r\n    for (let i = 0; i < audioSources.length; i++) {\r\n      const source = audioSources[i];\r\n      const { clip } = source;\r\n      \r\n      // 计算裁剪参数\r\n      const trimStart = clip.trimStart || 0;\r\n      const trimEnd = clip.trimEnd || (source.media.duration || clip.end - clip.start);\r\n      \r\n      // 创建音频处理链：裁剪 -> 设置时间戳 -> 延迟\r\n      filterComplex += `[${i + 1}:a]atrim=start=${trimStart}:end=${trimEnd},asetpts=PTS-STARTPTS,adelay=${clip.start * 1000}|${clip.start * 1000}[a${i}];`;\r\n      mixInputs.push(`[a${i}]`);\r\n    }\r\n\r\n    // 混合所有音频\r\n    filterComplex += `${mixInputs.join('')}amix=inputs=${mixInputs.length}:duration=longest:dropout_transition=0[aout]`;\r\n\r\n    console.log('🎛️ FFmpeg 滤镜链:', filterComplex);\r\n\r\n    onProgress(60);\r\n\r\n    // 第四步：执行音频混合\r\n    const inputFiles = ['-i', 'silence.wav'];\r\n    for (let i = 0; i < audioSources.length; i++) {\r\n      inputFiles.push('-i', `input_${i}.mp4`);\r\n    }\r\n\r\n    // 根据格式设置编码参数\r\n    let codecArgs: string[] = [];\r\n    const formatLower = options.format.toLowerCase();\r\n    \r\n    switch (formatLower) {\r\n      case 'mp3':\r\n        codecArgs = [\r\n          '-c:a', 'libmp3lame',\r\n          '-b:a', `${options.bitrate}k`,\r\n        ];\r\n        break;\r\n      case 'wav':\r\n        codecArgs = [\r\n          '-c:a', 'pcm_s16le',\r\n        ];\r\n        break;\r\n      case 'aac':\r\n        codecArgs = [\r\n          '-c:a', 'aac',\r\n          '-b:a', `${options.bitrate}k`,\r\n        ];\r\n        break;\r\n      case 'flac':\r\n        codecArgs = [\r\n          '-c:a', 'flac',\r\n        ];\r\n        break;\r\n      case 'aiff':\r\n        codecArgs = [\r\n          '-c:a', 'pcm_s16be',\r\n          '-f', 'aiff',\r\n        ];\r\n        break;\r\n      case 'ogg':\r\n        codecArgs = [\r\n          '-c:a', 'libvorbis',\r\n          '-b:a', `${options.bitrate}k`,\r\n        ];\r\n        break;\r\n      default:\r\n        codecArgs = [\r\n          '-c:a', 'libmp3lame',\r\n          '-b:a', `${options.bitrate}k`,\r\n        ];\r\n    }\r\n\r\n    console.log('🎚️ 开始混合音频...');\r\n    \r\n    await ffmpeg.exec([\r\n      ...inputFiles,\r\n      '-filter_complex', filterComplex,\r\n      '-map', '[aout]',\r\n      ...codecArgs,\r\n      '-ar', options.sampleRate.toString(),\r\n      '-t', duration.toString(),\r\n      `output.${formatLower}`\r\n    ]);\r\n\r\n    onProgress(90);\r\n\r\n    // 第五步：读取输出文件\r\n    console.log('📤 读取输出文件...');\r\n    const data = await ffmpeg.readFile(`output.${formatLower}`) as Uint8Array;\r\n    \r\n    // 清理临时文件\r\n    try {\r\n      await ffmpeg.deleteFile('silence.wav');\r\n      for (let i = 0; i < audioSources.length; i++) {\r\n        await ffmpeg.deleteFile(`input_${i}.mp4`);\r\n      }\r\n      await ffmpeg.deleteFile(`output.${formatLower}`);\r\n    } catch (e) {\r\n      console.warn('清理临时文件失败:', e);\r\n    }\r\n\r\n    onProgress(100);\r\n\r\n    // 确定MIME类型\r\n    let mimeType = 'audio/mpeg';\r\n    switch (formatLower) {\r\n      case 'mp3': mimeType = 'audio/mpeg'; break;\r\n      case 'wav': mimeType = 'audio/wav'; break;\r\n      case 'aac': mimeType = 'audio/aac'; break;\r\n      case 'flac': mimeType = 'audio/flac'; break;\r\n      case 'aiff': mimeType = 'audio/aiff'; break;\r\n      case 'ogg': mimeType = 'audio/ogg'; break;\r\n    }\r\n\r\n    const blob = new Blob([new Uint8Array(data.buffer as ArrayBuffer)], { type: mimeType });\r\n    console.log('✅ 音频导出完成！文件大小:', (blob.size / 1024 / 1024).toFixed(2), 'MB');\r\n    \r\n    return blob;\r\n  } catch (error) {\r\n    console.error('❌ 音频导出失败:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n"],"names":["ffmpegInstance","exportAudio","async","clips","mediaItems","onProgress","options","console","log","ffmpeg","FFmpeg","on","_ref","message","baseURL","load","coreURL","concat","wasmURL","getFFmpeg","duration","length","Math","max","map","c","end","Error","toFixed","audioSources","clip","media","find","m","id","mediaId","url","type","push","i","source","inputFileName","name","audioData","fetchFile","writeFile","exec","sampleRate","toString","filterComplex","mixInputs","trimStart","trimEnd","start","join","inputFiles","codecArgs","formatLower","format","toLowerCase","bitrate","data","readFile","deleteFile","e","warn","mimeType","blob","Blob","Uint8Array","buffer","size","error"],"sourceRoot":""}