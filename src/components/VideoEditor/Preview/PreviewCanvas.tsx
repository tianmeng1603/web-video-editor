import React, { useRef, useEffect, useState } from "react";
import { MediaItem, TimelineClip } from "../types";
import { MediaElement } from "./MediaElement";
import { MoveableControl } from "./MoveableControl";
import ZoomPanWrapper from "./ZoomPanWrapper";

interface PreviewCanvasProps {
  currentTime: number;
  clips: TimelineClip[];
  mediaItems: MediaItem[];
  isPlaying: boolean;
  canvasRatio?: string;
  selectedClipId?: string | null;
  onClipUpdate?: (id: string, updates: Partial<TimelineClip>) => void;
  onClipSelect?: (id: string | null) => void;
  forceUpdateTextRef?: React.MutableRefObject<(() => void) | null>;
}

const PreviewCanvasComponent: React.FC<PreviewCanvasProps> = ({
  currentTime,
  clips,
  mediaItems,
  isPlaying,
  canvasRatio = "16:9",
  selectedClipId,
  onClipUpdate,
  onClipSelect,
  forceUpdateTextRef,
}) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const canvasRef = useRef<HTMLDivElement>(null);
  const [containerSize, setContainerSize] = useState({ width: 0, height: 0 });

  // ÁîªÂ∏ÉÈÄâ‰∏≠Áä∂ÊÄÅ

  const videoRefs = useRef<{ [key: string]: HTMLVideoElement }>({});
  const audioRefs = useRef<{ [key: string]: HTMLAudioElement }>({});
  const textRefs = useRef<{ [key: string]: HTMLDivElement }>({});
  const isEditingRef = useRef<Set<string>>(new Set());

  // ÁõëÊéß clips ÂèòÂåñ
  useEffect(() => {
    console.log("üé® [PreviewCanvas] clips Áä∂ÊÄÅÊõ¥Êñ∞:", {
      clipsÊï∞Èáè: clips.length,
      clipIds: clips.map((c) => c.id),
    });
  }, [clips]);

  // Êèê‰æõÁªôÁà∂ÁªÑ‰ª∂ÁöÑÂº∫Âà∂Êõ¥Êñ∞ÊñáÂ≠óÂáΩÊï∞
  useEffect(() => {
    if (forceUpdateTextRef) {
      forceUpdateTextRef.current = () => {
        console.log("üîÑ Âº∫Âà∂Êõ¥Êñ∞ÊâÄÊúâÊñáÂ≠ó");
        // Ê∏ÖÈô§ÁºñËæëÁä∂ÊÄÅ
        isEditingRef.current.forEach((clipId) => {
          const textElement = textRefs.current[clipId];
          if (textElement && document.activeElement === textElement) {
            textElement.blur();
          }
        });
        isEditingRef.current.clear();

        // Âº∫Âà∂Êõ¥Êñ∞ÊâÄÊúâÊñáÂ≠óÂÜÖÂÆπ
        clips.forEach((clip) => {
          if (clip.text !== undefined && textRefs.current[clip.id]) {
            const textElement = textRefs.current[clip.id];
            textElement.textContent = clip.text || "Text";
            console.log(`  üìù Âº∫Âà∂Êõ¥Êñ∞ÊñáÂ≠ó: ${clip.id} -> "${clip.text}"`);
          }
        });
      };
    }
  }, [clips, forceUpdateTextRef]);

  // ÁõëÂê¨ÂÆπÂô®Â§ßÂ∞èÂèòÂåñÔºåÂè™Âú®ÂàùÂßãÂä†ËΩΩÂíåÊØî‰æãÂèòÂåñÊó∂Êõ¥Êñ∞
  useEffect(() => {
    if (!containerRef.current) return;

    const timer = setTimeout(() => {
      if (containerRef.current) {
        const rect = containerRef.current.getBoundingClientRect();
        setContainerSize({ width: rect.width, height: rect.height });
        console.log("Container size updated:", {
          width: rect.width,
          height: rect.height,
        });
      }
    }, 100);

    return () => clearTimeout(timer);
  }, [canvasRatio]); // ‰æùËµñcanvasRatioÔºåÊØî‰æãÂèòÂåñÊó∂ÈáçÊñ∞ËÆ°ÁÆó

  // ÂàùÂßãÂä†ËΩΩÊó∂Ëé∑ÂèñÂÆπÂô®Â§ßÂ∞è
  useEffect(() => {
    if (!containerRef.current) return;

    const timer = setTimeout(() => {
      if (containerRef.current) {
        const rect = containerRef.current.getBoundingClientRect();
        setContainerSize({ width: rect.width, height: rect.height });
        console.log("Initial container size:", {
          width: rect.width,
          height: rect.height,
        });
      }
    }, 50);

    return () => clearTimeout(timer);
  }, []); // Á©∫‰æùËµñÊï∞ÁªÑÔºåÂè™Âú®ÁªÑ‰ª∂ÊåÇËΩΩÊó∂ÊâßË°å‰∏ÄÊ¨°

  // Ê†πÊçÆÊØî‰æãÂíåÂÆπÂô®Â§ßÂ∞èËÆ°ÁÆóÁîªÂ∏ÉÂ§ßÂ∞èÔºå‰øùÊåÅ20pxÂÆâÂÖ®Ë∑ùÁ¶ª
  const getCanvasSize = () => {
    if (!containerSize.width || !containerSize.height) {
      return { width: 0, height: 0 };
    }

    let ratio: number;
    switch (canvasRatio) {
      case "16:9":
        ratio = 16 / 9;
        break;
      case "9:16":
        ratio = 9 / 16;
        break;
      case "1:1":
        ratio = 1;
        break;
      default:
        ratio = 16 / 9;
    }

    // ËÆ°ÁÆóÂèØÁî®Á©∫Èó¥ÔºàÂáèÂéª40pxÂÆâÂÖ®Ë∑ùÁ¶ªÔºö‰∏ä‰∏ãÂ∑¶Âè≥ÂêÑ20pxÔºâ
    const availableWidth = containerSize.width - 80;
    const availableHeight = containerSize.height - 80;

    // Ê†πÊçÆÂÆπÂô®Â§ßÂ∞èÂíåÊØî‰æãËÆ°ÁÆóÁîªÂ∏ÉÂ§ßÂ∞è
    const containerRatio = availableWidth / availableHeight;
    let canvasWidth, canvasHeight;

    if (containerRatio > ratio) {
      // ÂÆπÂô®Êõ¥ÂÆΩÔºå‰ª•È´òÂ∫¶‰∏∫ÂáÜ
      canvasHeight = availableHeight;
      canvasWidth = canvasHeight * ratio;
    } else {
      // ÂÆπÂô®Êõ¥È´òÔºå‰ª•ÂÆΩÂ∫¶‰∏∫ÂáÜ
      canvasWidth = availableWidth;
      canvasHeight = canvasWidth / ratio;
    }

    console.log("üìè ÁîªÂ∏ÉÂ∞∫ÂØ∏ËÆ°ÁÆó:", {
      ÂÆπÂô®Â§ßÂ∞è: containerSize,
      ÂèØÁî®Á©∫Èó¥: { width: availableWidth, height: availableHeight },
      ÁîªÂ∏ÉÂ§ßÂ∞è: {
        width: Math.round(canvasWidth),
        height: Math.round(canvasHeight),
      },
      ÊØî‰æã: canvasRatio,
      Ê†áÂáÜÂ∞∫ÂØ∏_16_9: "1920x1080",
      Ê†áÂáÜÂ∞∫ÂØ∏_9_16: "1080x1920",
      Ê†áÂáÜÂ∞∫ÂØ∏_1_1: "1080x1080",
    });

    return { width: canvasWidth, height: canvasHeight };
  };

  const canvasSize = getCanvasSize();

  // Ëé∑ÂèñÂΩìÂâçÊó∂Èó¥ÁÇπÂ∫îËØ•ÊòæÁ§∫ÁöÑÊâÄÊúâÁâáÊÆµ
  const getActiveClips = () => {
    return clips.filter(
      (clip) => currentTime >= clip.start && currentTime < clip.end
    );
  };

  const activeClips = getActiveClips();

  // Ë∞ÉËØïÔºöËÆ∞ÂΩï clips ÂèòÂåñ
  useEffect(() => {
    console.log("üé¨ [PreviewCanvas] clips ÂèòÂåñ", {
      totalClips: clips.length,
      activeClips: activeClips.length,
      clipIds: clips.map((c) => c.id).join(", "),
    });
  }, [clips, activeClips.length]);

  // Ê∏ÖÁêÜÊó†ÊïàÁöÑ refsÔºàÂΩìÁâáÊÆµË¢´Âà†Èô§Êó∂Ôºâ
  useEffect(() => {
    const validClipIds = new Set(clips.map((c) => c.id));

    // Ê∏ÖÁêÜÊó†ÊïàÁöÑËßÜÈ¢ëÂºïÁî®
    Object.keys(videoRefs.current).forEach((clipId) => {
      if (!validClipIds.has(clipId)) {
        delete videoRefs.current[clipId];
        console.log(`üóëÔ∏è Ê∏ÖÁêÜÊó†ÊïàÁöÑËßÜÈ¢ëÂºïÁî®: ${clipId}`);
      }
    });

    // Ê∏ÖÁêÜÊó†ÊïàÁöÑÈü≥È¢ëÂºïÁî®
    Object.keys(audioRefs.current).forEach((clipId) => {
      if (!validClipIds.has(clipId)) {
        delete audioRefs.current[clipId];
        console.log(`üóëÔ∏è Ê∏ÖÁêÜÊó†ÊïàÁöÑÈü≥È¢ëÂºïÁî®: ${clipId}`);
      }
    });

    // Ê∏ÖÁêÜÊó†ÊïàÁöÑÊñáÂ≠óÂºïÁî®
    Object.keys(textRefs.current).forEach((clipId) => {
      if (!validClipIds.has(clipId)) {
        delete textRefs.current[clipId];
        console.log(`üóëÔ∏è Ê∏ÖÁêÜÊó†ÊïàÁöÑÊñáÂ≠óÂºïÁî®: ${clipId}`);
      }
    });
  }, [clips]);

  // Ë∞ÉËØïÊó•Âøó
  console.log("PreviewCanvas render:", {
    canvasSize,
    containerSize,
    canvasRatio,
    activeClipsCount: activeClips.length,
    selectedClipId,
  });

  // ËßÜÈ¢ëÂíåÈü≥È¢ëÂêåÊ≠•ÈÄªËæë
  useEffect(() => {
    // ËÆ°ÁÆóÊó∂Èó¥Êò†Â∞ÑÔºöÊí≠ÊîæÂ§¥Ë¢´ÈôêÂà∂ÔºåÈúÄË¶ÅÊò†Â∞ÑÂà∞ÂÆåÊï¥Êó∂Èó¥ËåÉÂõ¥
    const maxClipEnd =
      clips.length > 0 ? Math.max(...clips.map((c) => c.end)) : 0;
    const playheadWidthTime = 2 / 100; // Êí≠ÊîæÂ§¥ÂÆΩÂ∫¶ÂØπÂ∫îÁöÑÊó∂Èó¥ÔºàÁ∫¶0.02ÁßíÔºâ
    const limitedMax = maxClipEnd - playheadWidthTime;

    // Â∞ÜÂèóÈôêÁöÑ currentTime [0, limitedMax] Êò†Â∞ÑÂà∞ [0, maxClipEnd]
    const timeScale = limitedMax > 0 ? maxClipEnd / limitedMax : 1;
    const mappedCurrentTime = currentTime * timeScale;

    activeClips.forEach((clip) => {
      const media = mediaItems.find((item) => item.id === clip.mediaId);

      // ËßÜÈ¢ëÂ§ÑÁêÜ
      if (media && media.type === "video") {
        const videoElement = videoRefs.current[clip.id];
        if (videoElement) {
          const timelineTime = mappedCurrentTime - clip.start;
          const clipDuration = clip.end - clip.start;

          const trimStart = clip.trimStart || 0;
          const clipDurationForTrim = clip.end - clip.start;
          const trimEnd =
            clip.trimEnd ||
            (media.duration ? media.duration : trimStart + clipDurationForTrim);

          if (timelineTime >= 0 && timelineTime <= clipDuration) {
            const videoTime = trimStart + timelineTime;
            const clampedVideoTime = Math.min(
              Math.max(trimStart, videoTime),
              trimEnd
            );

            videoElement.playbackRate = 1.0;

            if (Math.abs(videoElement.currentTime - clampedVideoTime) > 0.1) {
              videoElement.currentTime = clampedVideoTime;
            }
          }

          if (isPlaying && timelineTime >= 0 && timelineTime <= clipDuration) {
            const playPromise = videoElement.play();
            if (playPromise !== undefined) {
              playPromise.catch(() => {
                console.log("Video autoplay was prevented");
              });
            }
          } else {
            videoElement.pause();
          }
        }
      }

      // Èü≥È¢ëÂ§ÑÁêÜ
      if (media && media.type === "audio") {
        const audioElement = audioRefs.current[clip.id];
        if (audioElement) {
          const timelineTime = mappedCurrentTime - clip.start;
          const clipDuration = clip.end - clip.start;

          const trimStart = clip.trimStart || 0;
          const clipDurationForTrim = clip.end - clip.start;
          const trimEnd =
            clip.trimEnd ||
            (media.duration ? media.duration : trimStart + clipDurationForTrim);
          const audioSpeed = clip.speed || 1;
          const audioVolume = clip.volume ?? 100;

          // ËÆæÁΩÆÊí≠ÊîæÈÄüÂ∫¶
          audioElement.playbackRate = audioSpeed;

          // ËÆæÁΩÆÈü≥Èáè (HTMLMediaElement.volume ÂøÖÈ°ªÂú® [0, 1] ËåÉÂõ¥ÂÜÖ)
          audioElement.volume = Math.min(Math.max(audioVolume / 100, 0), 1);

          if (timelineTime >= 0 && timelineTime <= clipDuration) {
            const audioTime = trimStart + timelineTime;
            const clampedAudioTime = Math.min(
              Math.max(trimStart, audioTime),
              trimEnd
            );

            if (Math.abs(audioElement.currentTime - clampedAudioTime) > 0.1) {
              audioElement.currentTime = clampedAudioTime;
            }
          }

          if (isPlaying && timelineTime >= 0 && timelineTime <= clipDuration) {
            const playPromise = audioElement.play();
            if (playPromise !== undefined) {
              playPromise.catch(() => {
                console.log("Audio autoplay was prevented");
              });
            }
          } else {
            audioElement.pause();
          }
        }
      }
    });
  }, [currentTime, isPlaying, activeClips, mediaItems, clips]);

  return (
    <>
      <style>
        {`
          /* ÊéßÂà∂Ê°ÜËæπÊ°Ü */
          .moveable-control .moveable-control-box {
            border: 2px solid #4F46E5 !important;
          }
          
          /* ËæπÁ∫ø */
          .moveable-control .moveable-line {
            background-color: #4F46E5 !important;
          }
          
          /* ÊéßÂà∂ÁÇπÂü∫Á°ÄÊ†∑Âºè */
          .moveable-control .moveable-direction {
            width: 10px !important;
            height: 10px !important;
            background-color: #ffffff !important;
            border: 2px solid #4F46E5 !important;
            border-radius: 50% !important;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2) !important;
          }
          
          /* ÊóãËΩ¨ÊéßÂà∂ÁÇπ */
          .moveable-control .moveable-rotation {
            width: 24px !important;
            height: 24px !important;
            background-color: #ffffff !important;
            border: 2px solid #4F46E5 !important;
            border-radius: 50% !important;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3) !important;
            cursor: grab !important;
          }
          
          .moveable-control .moveable-rotation:hover {
            background-color: #4F46E5 !important;
            transform: scale(1.1) !important;
            transition: all 0.2s ease !important;
          }
          
          /* ÊéßÂà∂ÁÇπÊÇ¨ÂÅúÊïàÊûú */
          .moveable-control .moveable-direction:hover {
            background-color: #4F46E5 !important;
            transform: scale(1.2) !important;
            transition: all 0.2s ease !important;
          }
          
          /* ÊñáÂ≠óÊéßÂà∂Ê°ÜÁöÑÂè≥‰∏≠ÊéßÂà∂ÁÇπÂèòÊàêÈïøÊñπÂΩ¢ */
          .moveable-control-text .moveable-direction.moveable-e {
            width: 10px !important;
            height: 20px !important;
            border-radius: 5px !important;
            margin-left: -6px !important;
            margin-top: -10px !important;
          }
          
          /* Â™í‰ΩìÊéßÂà∂Ê°ÜÁöÑËßíÊéßÂà∂ÁÇπÊîæÂ§ß */
          .moveable-control-media .moveable-direction.moveable-nw,
          .moveable-control-media .moveable-direction.moveable-ne,
          .moveable-control-media .moveable-direction.moveable-sw,
          .moveable-control-media .moveable-direction.moveable-se {
            width: 12px !important;
            height: 12px !important;
          }
        `}
      </style>
      <div
        ref={containerRef}
        className="relative flex items-center justify-center w-full h-full overflow-hidden bg-gray-200"
      >
        {/* ÂèØÁº©ÊîæÁßªÂä®ÁöÑÊï¥‰∏™ÁîªÂ∏ÉÂå∫Âüü */}
        <ZoomPanWrapper
          disabled={false}
          minScale={0.1}
          maxScale={5}
          initialScale={1}
          canvasRatio={canvasRatio}
          onTransformChange={(transform) => {
            console.log("Transform changed:", transform);
          }}
          onClick={() => {
            // ÁÇπÂáªÁîªÂ∏ÉËÉåÊôØÔºàÈùûÊãñÂä®ÔºâÊó∂ÂèñÊ∂àÈÄâ‰∏≠
            console.log("üñ±Ô∏è ÁÇπÂáªÁîªÂ∏ÉËÉåÊôØÔºåÂèñÊ∂àÈÄâ‰∏≠");
            onClipSelect?.(null);
          }}
        >
          <div className="flex items-center justify-center w-full h-full">
            <div
              className="relative"
              style={{
                width: canvasSize.width > 0 ? `${canvasSize.width}px` : "100%",
                height:
                  canvasSize.height > 0 ? `${canvasSize.height}px` : "100%",
                minWidth: "100px",
                minHeight: "100px",
              }}
            >
              {/* ÈªëËâ≤ÁîªÂ∏ÉËÉåÊôØ */}
              <div
                id="preview-canvas-bg"
                data-width={canvasSize.width}
                data-height={canvasSize.height}
                className="absolute bg-black"
                style={{
                  width: "100%",
                  height: "100%",
                  zIndex: -1,
                }}
              />

              {/* ÁîªÂ∏ÉÂ§ñÂ±ÇÂÆπÂô®ÔºöÂÆûÈôÖÊòæÁ§∫Â∞∫ÂØ∏ */}
              <div
                className="relative overflow-hidden"
                style={{
                  width: `${canvasSize.width}px`,
                  height: `${canvasSize.height}px`,
                }}
              >
                {/* ÁîªÂ∏ÉÂÜÖÂÆπÂ±ÇÔºöÂõ∫ÂÆö 1920x1080ÔºåÈÄöËøá scale Áº©ÊîæÂà∞ÂÆûÈôÖÂ∞∫ÂØ∏ */}
                <div
                  ref={canvasRef}
                  id="preview-canvas"
                  className="relative"
                  style={{
                    width: "1920px",
                    height: "1080px",
                    transform: `scale(${canvasSize.width / 1920})`,
                    transformOrigin: "top left",
                  }}
                >
                  {/* Èü≥È¢ëÂÖÉÁ¥†Ôºö‰∏çÊòæÁ§∫‰ΩÜÈúÄË¶ÅÊí≠ÊîæÂ£∞Èü≥ */}
                  {activeClips
                    .filter((clip) => {
                      const media = mediaItems.find(
                        (item) => item.id === clip.mediaId
                      );
                      return media?.type === "audio";
                    })
                    .map((clip) => {
                      const media = mediaItems.find(
                        (item) => item.id === clip.mediaId
                      );
                      if (!media) return null;

                      return (
                        <audio
                          key={clip.id}
                          ref={(el) => {
                            if (el) {
                              audioRefs.current[clip.id] = el;
                              // Â∫îÁî®Èü≥È¢ëÊ†∑Âºè
                              if (clip.volume !== undefined) {
                                // HTMLMediaElement.volume ÂøÖÈ°ªÂú® [0, 1] ËåÉÂõ¥ÂÜÖ
                                el.volume = Math.min(clip.volume / 100, 1);
                              }
                              if (clip.speed !== undefined) {
                                el.playbackRate = clip.speed;
                              }
                            }
                          }}
                          src={media.url}
                          style={{ display: "none" }}
                        />
                      );
                    })}

                  {/* ËßÜËßâÂÖÉÁ¥†ÔºöÊåâËΩ®ÈÅìÈ°∫Â∫èÊòæÁ§∫ */}
                  {activeClips
                    .sort((a, b) => b.trackIndex - a.trackIndex)
                    .map((clip) => {
                      const media = mediaItems.find(
                        (item) => item.id === clip.mediaId
                      );
                      if (!media || media.type === "audio") return null;

                      return (
                        <React.Fragment key={clip.id}>
                          <MediaElement
                            clip={clip}
                            media={media}
                            canvasSize={{ width: 1920, height: 1080 }}
                            selectedClipId={selectedClipId}
                            isEditingRef={isEditingRef}
                            textRefs={textRefs}
                            videoRefs={videoRefs}
                            onClipSelect={onClipSelect}
                            onClipUpdate={onClipUpdate}
                          />
                        </React.Fragment>
                      );
                    })}
                </div>

                {/* Moveable ÊéßÂà∂Ê°Ü - Áé∞Âú®‰πüÂú®ÂèØÁº©ÊîæÂå∫ÂüüÂÜÖ */}
                {activeClips
                  .filter((clip) => {
                    const media = mediaItems.find(
                      (item) => item.id === clip.mediaId
                    );
                    return (
                      media &&
                      media.type !== "audio" &&
                      selectedClipId === clip.id
                    );
                  })
                  .map((clip) => {
                    const media = mediaItems.find(
                      (item) => item.id === clip.mediaId
                    );
                    if (!media) return null;

                    console.log("Rendering MoveableControl for clip:", clip.id);

                    // ÁîüÊàêÂåÖÂê´Ë£ÅÂâ™‰ø°ÊÅØÂíåÂ∞∫ÂØ∏ÁöÑ keyÔºåÁ°Æ‰øùË£ÅÂâ™Âêé MoveableControl ÈáçÊñ∞ÊåÇËΩΩ
                    const cropKey = clip.cropArea
                      ? `crop-${clip.cropArea.x}-${clip.cropArea.y}-${clip.cropArea.width}-${clip.cropArea.height}`
                      : "no-crop";
                    const moveableKey = `${clip.id}-${cropKey}-${clip.width}-${clip.height}`;

                    return (
                      <MoveableControl
                        key={moveableKey}
                        clip={clip}
                        media={media}
                        canvasSize={{ width: 1920, height: 1080 }}
                        onClipUpdate={onClipUpdate}
                      />
                    );
                  })}
              </div>
              {/* ÂÖ≥Èó≠ÁîªÂ∏ÉÂÜÖÂÆπÂ±Ç */}
            </div>
            {/* ÂÖ≥Èó≠ÁîªÂ∏ÉÂ§ñÂ±ÇÂÆπÂô® */}
          </div>
        </ZoomPanWrapper>
      </div>
    </>
  );
};

// Ëá™ÂÆö‰πâÊØîËæÉÂáΩÊï∞ÔºåÁ°Æ‰øù clips ÂèòÂåñÊó∂ÈáçÊñ∞Ê∏≤Êüì
const arePropsEqual = (
  prevProps: PreviewCanvasProps,
  nextProps: PreviewCanvasProps
) => {
  // clips Êï∞ÁªÑÂºïÁî®ÊàñÈïøÂ∫¶ÂèòÂåñÊó∂ÔºåÂøÖÈ°ªÈáçÊñ∞Ê∏≤Êüì
  const clipsChanged =
    prevProps.clips !== nextProps.clips ||
    prevProps.clips.length !== nextProps.clips.length;

  if (clipsChanged) {
    console.log("üîÑ [PreviewCanvas] clips ÂèòÂåñÔºåÂº∫Âà∂ÈáçÊñ∞Ê∏≤Êüì", {
      prevLength: prevProps.clips.length,
      nextLength: nextProps.clips.length,
      Áõ∏ÂêåÂºïÁî®: prevProps.clips === nextProps.clips,
    });
    return false; // ÈúÄË¶ÅÈáçÊñ∞Ê∏≤Êüì
  }

  // ÂÖ∂‰ªñ props ÊØîËæÉ
  return (
    prevProps.currentTime === nextProps.currentTime &&
    prevProps.isPlaying === nextProps.isPlaying &&
    prevProps.canvasRatio === nextProps.canvasRatio &&
    prevProps.selectedClipId === nextProps.selectedClipId &&
    prevProps.mediaItems === nextProps.mediaItems
  );
};

export const PreviewCanvas = React.memo(PreviewCanvasComponent, arePropsEqual);
